// compiled by Andy DeSoto, March 2013// this is the canonical version, downloaded from http://flash.technimentis.com/resources/package { 	import flash.net.*;	import flash.events.*;	import flash.utils.*;	import flash.filesystem.*;	public class PsychologyDataHandler	{		//file variables		var file:File = new File();		var stream:FileStream = new FileStream();		var writeDelayTime:int = 100;		var writeDelayTimer:Timer = new Timer(writeDelayTime,0);		var writeData:Array = [];		var writeIndex:int = 0;		//URL  variables		var varLoader:URLLoader = new URLLoader();		var varURL:URLRequest = new URLRequest();		var submittedData:URLVariables = new URLVariables();		var uploadDelayTime:int = 100;		var uploadDelayTimer:Timer = new Timer(uploadDelayTime,0);		var uploadData:Array = [];		var uploadIndex:int = 0;		public function setURL(s:String):void {			varURL = new URLRequest(s);			varURL.data = submittedData;			varURL.method = URLRequestMethod.POST;		}		public function setFile(s:String):void {			file = File.desktopDirectory.resolvePath(s);			stream.open(file, FileMode.APPEND);		}		public function upload(s:String):void {			submittedData.inputData = s;			varLoader.load(varURL);		}		public function write(s:String):void {			stream.writeUTFBytes(s + "\r\n");		}		public function delimitArray(a:Array):String {			var temp:String = new String;			for (var i=0; i < a.length; i++) {				if (i!=0) {					temp +=  "*";				}				temp +=  String(a[i]);			}			temp +=  "*";			return temp;		}		public function shuffleArray(a:Array):Array		{			// RETURNS A DEEP COPY, LEAVING A UNCHANGED			//taken from http://www.daveoncode.com/2009/01/08/implementing-arrayshuffle-in-actionscript/			var temp:Array = [];			var aClone = cloneItem(a);						while (aClone.length > 0)			{				temp.push(aClone.splice(Math.round(Math.random() * (aClone.length - 1)), 1)[0]);			}			return temp;						/*			var aClone = h.clone(a);			var temp:Array = new Array();				for (var i:int = 0; i < aClone.length; i++)			{				var intRand:int = Math.floor(Math.random()*aClone.length);				while (aClone[intRand] == null)				{					intRand = Math.floor(Math.random()*a.length);				}				temp.push(a[intRand]);				a[intRand] = null;			}					return temp;*/					}				public function cloneItem(source:Object):* 		{ 			var myBA:ByteArray = new ByteArray(); 			myBA.writeObject(source); 			myBA.position = 0; 			return(myBA.readObject()); 		}		public function initializeUploadBuffer():void {			uploadData = [];			uploadIndex = 0;		}		public function toUploadBuffer(s:String):void {			uploadData.push(s);		}		public function uploadUploadBuffer():void {			uploadDelayTimer.addEventListener(TimerEvent.TIMER, tickUploadBuffer);			uploadDelayTimer.start();		}		public function tickUploadBuffer(evt:TimerEvent):void {			if (uploadIndex < uploadData.length) {				upload(uploadData[uploadIndex]);				uploadIndex++;			}			else {				uploadDelayTimer.removeEventListener(TimerEvent.TIMER, tickUploadBuffer);			}		}		public function set setUploadDelayTime(i:int) {			uploadDelayTime = i;			uploadDelayTimer = new Timer(uploadDelayTime,0);		}		public function initializeWriteBuffer():void {			writeData = [];			writeIndex = 0;		}		public function toWriteBuffer(s:String):void {			writeData.push(s);		}		public function writeWriteBuffer():void {			writeDelayTimer.addEventListener(TimerEvent.TIMER, tickWriteBuffer);			writeDelayTimer.start();		}		public function tickWriteBuffer(evt:TimerEvent):void {			if (writeIndex < writeData.length) {				write(writeData[writeIndex]);				writeIndex++;			}			else {				writeDelayTimer.removeEventListener(TimerEvent.TIMER, tickWriteBuffer);			}		}		public function set setWriteDelayTime(i:int) {			writeDelayTime = i;			writeDelayTimer = new Timer(writeDelayTime,0);		}				public function trimWhitespace($string:String):String {			if ($string == null) {				return "";			}			return $string.replace(/^\s+|\s+$/g, "");		}	}}